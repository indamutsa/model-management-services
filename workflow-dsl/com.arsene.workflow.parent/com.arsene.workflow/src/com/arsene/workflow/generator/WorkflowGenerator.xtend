/*
 * generated by Xtext 2.25.0
 */
package com.arsene.workflow.generator

import com.arsene.workflow.workflow.And
import com.arsene.workflow.workflow.ArithmeticSigned
import com.arsene.workflow.workflow.Assignment
import com.arsene.workflow.workflow.BoolConstant
import com.arsene.workflow.workflow.Comparison
import com.arsene.workflow.workflow.Display
import com.arsene.workflow.workflow.Equality
import com.arsene.workflow.workflow.Expo
import com.arsene.workflow.workflow.IntConstant
import com.arsene.workflow.workflow.Minus
import com.arsene.workflow.workflow.Mod
import com.arsene.workflow.workflow.MulOrDiv
import com.arsene.workflow.workflow.Not
import com.arsene.workflow.workflow.Or
import com.arsene.workflow.workflow.Plus
import com.arsene.workflow.workflow.StringConstant
import com.arsene.workflow.workflow.Variable
import com.arsene.workflow.workflow.VariableRef
import com.arsene.workflow.workflow.WorkflowProgramModel
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import com.arsene.workflow.workflow.Statement
import com.arsene.workflow.workflow.IfStatement
import com.arsene.workflow.workflow.Block
import com.arsene.workflow.workflow.LoopStatement
import com.arsene.workflow.workflow.Method
import com.arsene.workflow.workflow.PrimitiveType
import com.arsene.workflow.workflow.Workflow
import com.arsene.workflow.workflow.WorkflowType
import com.arsene.workflow.workflow.Step
import com.arsene.workflow.workflow.Return
import com.arsene.workflow.workflow.MethodInvocation
import java.lang.invoke.MethodHandles.Lookup

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class WorkflowGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {

		var generatedCode = ""
		val program = resource.allContents.toIterable.filter(WorkflowProgramModel).head

		if (program === null)
			return;

		for (feature : program.features) {
			if (feature.statement !== null) {
				var statement = feature.statement
				val codeGenerated = compileStatement(statement)
				generatedCode += codeGenerated
			} else if (feature.method !== null) {
				var method = feature.method
				val codeGenerated = method.compileMethod
				generatedCode += codeGenerated
			} else if (feature.workflow !== null) {
				var workflow = feature.workflow
				val codeGenerated = workflow.compileWorkflow
				generatedCode += codeGenerated
			}
		}
		fsa.generateFile("generated_code.js", generatedCode)
	}

	def dispatch CharSequence compileWorkflow(Workflow it) {
		'''
			function «name» («type») {
				let workflowType = "«type»"
				«FOR step : steps»«step.compileStep»
				«ENDFOR»
			}
			«name»()
		'''
	}

	def dispatch CharSequence compileStep(Step it) {
//		name = name.replaceAll("[\\W]|_", "")
		'''
			function «name.replaceAll("[\\W]|_", "")»()«body.compileBlock»
			«name.replaceAll("[\\W]|_", "")»()
		'''
	}

	def dispatch CharSequence compileMethod(Method it) {
		val p = params.map(p|"" + p.compile + "").join(', ')
		'''function «name»«if(params.length === 0) "()" else "(" + p + ")"»«body.compileBlock»'''
	}

	def compileStatement(Statement statement) {
		var generatedCode = ""

		if (statement.variabl !== null) {
			generatedCode += statement.variabl.compile
		} else if (statement.assignment !== null) {
			generatedCode += statement.assignment.compile
		} else if (statement.print !== null) {
			generatedCode += statement.print.compile
		} else if (statement.ifStatement !== null) {
			generatedCode += statement.ifStatement.compile
		} else if (statement.loop !== null) {
			generatedCode += statement.loop.compile
		} else if (statement.methodInvocation !== null) {
			generatedCode += statement.methodInvocation.compile
		}

		return generatedCode
	}

	def dispatch CharSequence compile(IfStatement it) {
		'''if(«expression.compile»)«thenBlock.compileBlock»«IF elseBlock !== null»else«elseBlock.compileBlock»«ENDIF»'''
	}

	def dispatch CharSequence compile(LoopStatement it) {
		'''while(«expression.compile»)«thenBlock.compileBlock»'''
	}
	
	def dispatch CharSequence compile(MethodInvocation it){
		val p = args.map(arg|"" + arg.compile + "").join(', ')
		
		'''«if(invokedMethod !== null) invokedMethod.name else if(service !== null) service.name»«if(args.length === 0) "()" else "(" + p + ")"»'''
	}

	def compileBlock(Block block) {
		'''{«FOR statement : block.statements»
		«compileStatement(statement)»
		«ENDFOR»«if (block.returnStatement !== null) block.returnStatement.compile»}'''
	}

	def dispatch CharSequence compile(Return it) {
		'''return «expression.compile»'''
	}

// ---------------------------------------- VARIABLE ---------------------------------------------
	def dispatch CharSequence compile(Variable it) {
		if (it.eContainer instanceof Method)
			'''«name»'''
		else
			'''
				let «name» = « if (expression !== null) expression.compile else if(methodInvocation !== null) methodInvocation.compile»
			'''
	}

	def dispatch CharSequence compile(VariableRef it) {
		'''«variable.name»'''
	}

	def dispatch CharSequence compile(Assignment it) {
		'''
			«variable.name» = «expression.compile»
		'''
	}

	// Compiling expressions
	def dispatch CharSequence compile(And it) {
		'''«left.compile» and «right.compile»'''
	}

	def dispatch CharSequence compile(Or it) {
		'''«left.compile» or «right.compile»'''
	}

	def dispatch CharSequence compile(Plus it) {
		'''«left.compile» + «right.compile»'''
	}

	def dispatch CharSequence compile(Minus it) {
		'''«left.compile» - «right.compile»'''
	}

	def dispatch CharSequence compile(Expo it) {
		'''«left.compile» ^ «right.compile»'''
	}

	def dispatch CharSequence compile(Mod it) {
		'''«left.compile» % «right.compile»'''
	}

	def dispatch CharSequence compile(MulOrDiv it) {
		'''«left.compile» «op» «right.compile»'''
	}

	def dispatch CharSequence compile(ArithmeticSigned it) {
		'''-«expression.compile»'''
	}

	def dispatch CharSequence compile(Not it) {
		'''!(«expression.compile»)'''
	}

	def dispatch CharSequence compile(Equality it) {
		'''«left.compile»«IF op.equals("==")» === «ELSE» !== «ENDIF»«right.compile»'''
	}

	def dispatch CharSequence compile(Comparison it) {
		'''«left.compile» «op» «right.compile»'''

	}

	def dispatch CharSequence compile(Display it) {
//		val p = exprs.map(p| "(" + p.compile + ")").join(' + ')
		// function printOutput shall be implemented in the front side of the web
		'''
			window.printConsoleOutput(«expression.compile»)
		'''
	}

	def dispatch CharSequence compile(PrimitiveType it) {
		'''«name»'''
	}

	// Compiling the constants
	def dispatch CharSequence compile(IntConstant it) {
		'''«value.toString»'''
	}

	def dispatch CharSequence compile(StringConstant it) {
		'"' + value + '"'
	}

	def dispatch CharSequence compile(BoolConstant it) {
		'''«value»'''
	}
}
