/**
 * generated by Xtext 2.25.0
 */
package com.arsene.workflow.generator;

import com.arsene.workflow.workflow.And;
import com.arsene.workflow.workflow.ArithmeticSigned;
import com.arsene.workflow.workflow.Assignment;
import com.arsene.workflow.workflow.Block;
import com.arsene.workflow.workflow.BoolConstant;
import com.arsene.workflow.workflow.Comparison;
import com.arsene.workflow.workflow.Display;
import com.arsene.workflow.workflow.Equality;
import com.arsene.workflow.workflow.Expo;
import com.arsene.workflow.workflow.Expression;
import com.arsene.workflow.workflow.Feature;
import com.arsene.workflow.workflow.IfStatement;
import com.arsene.workflow.workflow.IntConstant;
import com.arsene.workflow.workflow.LoopStatement;
import com.arsene.workflow.workflow.Method;
import com.arsene.workflow.workflow.MethodInvocation;
import com.arsene.workflow.workflow.Minus;
import com.arsene.workflow.workflow.Mod;
import com.arsene.workflow.workflow.MulOrDiv;
import com.arsene.workflow.workflow.Not;
import com.arsene.workflow.workflow.Or;
import com.arsene.workflow.workflow.Plus;
import com.arsene.workflow.workflow.PrimitiveType;
import com.arsene.workflow.workflow.Return;
import com.arsene.workflow.workflow.Service;
import com.arsene.workflow.workflow.Statement;
import com.arsene.workflow.workflow.Step;
import com.arsene.workflow.workflow.StringConstant;
import com.arsene.workflow.workflow.Variable;
import com.arsene.workflow.workflow.VariableRef;
import com.arsene.workflow.workflow.Workflow;
import com.arsene.workflow.workflow.WorkflowProgramModel;
import com.arsene.workflow.workflow.WorkflowType;
import com.google.common.collect.Iterables;
import java.util.Arrays;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class WorkflowGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    String generatedCode = "";
    final WorkflowProgramModel program = IterableExtensions.<WorkflowProgramModel>head(Iterables.<WorkflowProgramModel>filter(IteratorExtensions.<EObject>toIterable(resource.getAllContents()), WorkflowProgramModel.class));
    if ((program == null)) {
      return;
    }
    EList<Feature> _features = program.getFeatures();
    for (final Feature feature : _features) {
      Statement _statement = feature.getStatement();
      boolean _tripleNotEquals = (_statement != null);
      if (_tripleNotEquals) {
        Statement statement = feature.getStatement();
        final String codeGenerated = this.compileStatement(statement);
        String _generatedCode = generatedCode;
        generatedCode = (_generatedCode + codeGenerated);
      } else {
        Method _method = feature.getMethod();
        boolean _tripleNotEquals_1 = (_method != null);
        if (_tripleNotEquals_1) {
          Method method = feature.getMethod();
          final CharSequence codeGenerated_1 = this.compileMethod(method);
          String _generatedCode_1 = generatedCode;
          generatedCode = (_generatedCode_1 + codeGenerated_1);
        } else {
          Workflow _workflow = feature.getWorkflow();
          boolean _tripleNotEquals_2 = (_workflow != null);
          if (_tripleNotEquals_2) {
            Workflow workflow = feature.getWorkflow();
            final CharSequence codeGenerated_2 = this.compileWorkflow(workflow);
            String _generatedCode_2 = generatedCode;
            generatedCode = (_generatedCode_2 + codeGenerated_2);
          }
        }
      }
    }
    fsa.generateFile("generated_code.js", generatedCode);
  }
  
  protected CharSequence _compileWorkflow(final Workflow it) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("function ");
    String _name = it.getName();
    _builder.append(_name);
    _builder.append(" (");
    WorkflowType _type = it.getType();
    _builder.append(_type);
    _builder.append(") {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("let workflowType = \"");
    WorkflowType _type_1 = it.getType();
    _builder.append(_type_1, "\t");
    _builder.append("\"");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    {
      EList<Step> _steps = it.getSteps();
      for(final Step step : _steps) {
        CharSequence _compileStep = this.compileStep(step);
        _builder.append(_compileStep, "\t");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("}");
    _builder.newLine();
    String _name_1 = it.getName();
    _builder.append(_name_1);
    _builder.append("()");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  protected CharSequence _compileStep(final Step it) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("function ");
    String _replaceAll = it.getName().replaceAll("[\\W]|_", "");
    _builder.append(_replaceAll);
    _builder.append("()");
    CharSequence _compileBlock = this.compileBlock(it.getBody());
    _builder.append(_compileBlock);
    _builder.newLineIfNotEmpty();
    String _replaceAll_1 = it.getName().replaceAll("[\\W]|_", "");
    _builder.append(_replaceAll_1);
    _builder.append("()");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  protected CharSequence _compileMethod(final Method it) {
    CharSequence _xblockexpression = null;
    {
      final Function1<Variable, String> _function = (Variable p) -> {
        CharSequence _compile = this.compile(p);
        String _plus = ("" + _compile);
        return (_plus + "");
      };
      final String p = IterableExtensions.join(ListExtensions.<Variable, String>map(it.getParams(), _function), ", ");
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("function ");
      String _name = it.getName();
      _builder.append(_name);
      String _xifexpression = null;
      int _length = ((Object[])Conversions.unwrapArray(it.getParams(), Object.class)).length;
      boolean _tripleEquals = (_length == 0);
      if (_tripleEquals) {
        _xifexpression = "()";
      } else {
        _xifexpression = (("(" + p) + ")");
      }
      _builder.append(_xifexpression);
      CharSequence _compileBlock = this.compileBlock(it.getBody());
      _builder.append(_compileBlock);
      _xblockexpression = _builder;
    }
    return _xblockexpression;
  }
  
  public String compileStatement(final Statement statement) {
    String generatedCode = "";
    Variable _variabl = statement.getVariabl();
    boolean _tripleNotEquals = (_variabl != null);
    if (_tripleNotEquals) {
      String _generatedCode = generatedCode;
      CharSequence _compile = this.compile(statement.getVariabl());
      generatedCode = (_generatedCode + _compile);
    } else {
      Assignment _assignment = statement.getAssignment();
      boolean _tripleNotEquals_1 = (_assignment != null);
      if (_tripleNotEquals_1) {
        String _generatedCode_1 = generatedCode;
        CharSequence _compile_1 = this.compile(statement.getAssignment());
        generatedCode = (_generatedCode_1 + _compile_1);
      } else {
        Display _print = statement.getPrint();
        boolean _tripleNotEquals_2 = (_print != null);
        if (_tripleNotEquals_2) {
          String _generatedCode_2 = generatedCode;
          CharSequence _compile_2 = this.compile(statement.getPrint());
          generatedCode = (_generatedCode_2 + _compile_2);
        } else {
          IfStatement _ifStatement = statement.getIfStatement();
          boolean _tripleNotEquals_3 = (_ifStatement != null);
          if (_tripleNotEquals_3) {
            String _generatedCode_3 = generatedCode;
            CharSequence _compile_3 = this.compile(statement.getIfStatement());
            generatedCode = (_generatedCode_3 + _compile_3);
          } else {
            LoopStatement _loop = statement.getLoop();
            boolean _tripleNotEquals_4 = (_loop != null);
            if (_tripleNotEquals_4) {
              String _generatedCode_4 = generatedCode;
              CharSequence _compile_4 = this.compile(statement.getLoop());
              generatedCode = (_generatedCode_4 + _compile_4);
            } else {
              Expression _methodInvocation = statement.getMethodInvocation();
              boolean _tripleNotEquals_5 = (_methodInvocation != null);
              if (_tripleNotEquals_5) {
                String _generatedCode_5 = generatedCode;
                CharSequence _compile_5 = this.compile(statement.getMethodInvocation());
                generatedCode = (_generatedCode_5 + _compile_5);
              }
            }
          }
        }
      }
    }
    return generatedCode;
  }
  
  protected CharSequence _compile(final IfStatement it) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("if(");
    CharSequence _compile = this.compile(it.getExpression());
    _builder.append(_compile);
    _builder.append(")");
    CharSequence _compileBlock = this.compileBlock(it.getThenBlock());
    _builder.append(_compileBlock);
    {
      Block _elseBlock = it.getElseBlock();
      boolean _tripleNotEquals = (_elseBlock != null);
      if (_tripleNotEquals) {
        _builder.append("else");
        CharSequence _compileBlock_1 = this.compileBlock(it.getElseBlock());
        _builder.append(_compileBlock_1);
      }
    }
    return _builder;
  }
  
  protected CharSequence _compile(final LoopStatement it) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("while(");
    CharSequence _compile = this.compile(it.getExpression());
    _builder.append(_compile);
    _builder.append(")");
    CharSequence _compileBlock = this.compileBlock(it.getThenBlock());
    _builder.append(_compileBlock);
    return _builder;
  }
  
  protected CharSequence _compile(final MethodInvocation it) {
    CharSequence _xblockexpression = null;
    {
      final Function1<Expression, String> _function = (Expression arg) -> {
        CharSequence _compile = this.compile(arg);
        String _plus = ("" + _compile);
        return (_plus + "");
      };
      final String p = IterableExtensions.join(ListExtensions.<Expression, String>map(it.getArgs(), _function), ", ");
      StringConcatenation _builder = new StringConcatenation();
      String _xifexpression = null;
      Method _invokedMethod = it.getInvokedMethod();
      boolean _tripleNotEquals = (_invokedMethod != null);
      if (_tripleNotEquals) {
        _xifexpression = it.getInvokedMethod().getName();
      } else {
        String _xifexpression_1 = null;
        Service _service = it.getService();
        boolean _tripleNotEquals_1 = (_service != null);
        if (_tripleNotEquals_1) {
          _xifexpression_1 = it.getService().getName();
        }
        _xifexpression = _xifexpression_1;
      }
      _builder.append(_xifexpression);
      String _xifexpression_2 = null;
      int _length = ((Object[])Conversions.unwrapArray(it.getArgs(), Object.class)).length;
      boolean _tripleEquals = (_length == 0);
      if (_tripleEquals) {
        _xifexpression_2 = "()";
      } else {
        _xifexpression_2 = (("(" + p) + ")");
      }
      _builder.append(_xifexpression_2);
      _xblockexpression = _builder;
    }
    return _xblockexpression;
  }
  
  public CharSequence compileBlock(final Block block) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("{");
    {
      EList<Statement> _statements = block.getStatements();
      for(final Statement statement : _statements) {
        _builder.newLineIfNotEmpty();
        String _compileStatement = this.compileStatement(statement);
        _builder.append(_compileStatement);
        _builder.newLineIfNotEmpty();
      }
    }
    CharSequence _xifexpression = null;
    Return _returnStatement = block.getReturnStatement();
    boolean _tripleNotEquals = (_returnStatement != null);
    if (_tripleNotEquals) {
      _xifexpression = this.compile(block.getReturnStatement());
    }
    _builder.append(_xifexpression);
    _builder.append("}");
    return _builder;
  }
  
  protected CharSequence _compile(final Return it) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("return ");
    CharSequence _compile = this.compile(it.getExpression());
    _builder.append(_compile);
    return _builder;
  }
  
  protected CharSequence _compile(final Variable it) {
    CharSequence _xifexpression = null;
    EObject _eContainer = it.eContainer();
    if ((_eContainer instanceof Method)) {
      StringConcatenation _builder = new StringConcatenation();
      String _name = it.getName();
      _builder.append(_name);
      _xifexpression = _builder;
    } else {
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("let ");
      String _name_1 = it.getName();
      _builder_1.append(_name_1);
      _builder_1.append(" = ");
      CharSequence _xifexpression_1 = null;
      Expression _expression = it.getExpression();
      boolean _tripleNotEquals = (_expression != null);
      if (_tripleNotEquals) {
        _xifexpression_1 = this.compile(it.getExpression());
      } else {
        CharSequence _xifexpression_2 = null;
        Expression _methodInvocation = it.getMethodInvocation();
        boolean _tripleNotEquals_1 = (_methodInvocation != null);
        if (_tripleNotEquals_1) {
          _xifexpression_2 = this.compile(it.getMethodInvocation());
        }
        _xifexpression_1 = _xifexpression_2;
      }
      _builder_1.append(_xifexpression_1);
      _builder_1.newLineIfNotEmpty();
      _xifexpression = _builder_1;
    }
    return _xifexpression;
  }
  
  protected CharSequence _compile(final VariableRef it) {
    StringConcatenation _builder = new StringConcatenation();
    String _name = it.getVariable().getName();
    _builder.append(_name);
    return _builder;
  }
  
  protected CharSequence _compile(final Assignment it) {
    StringConcatenation _builder = new StringConcatenation();
    String _name = it.getVariable().getName();
    _builder.append(_name);
    _builder.append(" = ");
    CharSequence _compile = this.compile(it.getExpression());
    _builder.append(_compile);
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  protected CharSequence _compile(final And it) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _compile = this.compile(it.getLeft());
    _builder.append(_compile);
    _builder.append(" and ");
    CharSequence _compile_1 = this.compile(it.getRight());
    _builder.append(_compile_1);
    return _builder;
  }
  
  protected CharSequence _compile(final Or it) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _compile = this.compile(it.getLeft());
    _builder.append(_compile);
    _builder.append(" or ");
    CharSequence _compile_1 = this.compile(it.getRight());
    _builder.append(_compile_1);
    return _builder;
  }
  
  protected CharSequence _compile(final Plus it) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _compile = this.compile(it.getLeft());
    _builder.append(_compile);
    _builder.append(" + ");
    CharSequence _compile_1 = this.compile(it.getRight());
    _builder.append(_compile_1);
    return _builder;
  }
  
  protected CharSequence _compile(final Minus it) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _compile = this.compile(it.getLeft());
    _builder.append(_compile);
    _builder.append(" - ");
    CharSequence _compile_1 = this.compile(it.getRight());
    _builder.append(_compile_1);
    return _builder;
  }
  
  protected CharSequence _compile(final Expo it) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _compile = this.compile(it.getLeft());
    _builder.append(_compile);
    _builder.append(" ^ ");
    CharSequence _compile_1 = this.compile(it.getRight());
    _builder.append(_compile_1);
    return _builder;
  }
  
  protected CharSequence _compile(final Mod it) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _compile = this.compile(it.getLeft());
    _builder.append(_compile);
    _builder.append(" % ");
    CharSequence _compile_1 = this.compile(it.getRight());
    _builder.append(_compile_1);
    return _builder;
  }
  
  protected CharSequence _compile(final MulOrDiv it) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _compile = this.compile(it.getLeft());
    _builder.append(_compile);
    _builder.append(" ");
    String _op = it.getOp();
    _builder.append(_op);
    _builder.append(" ");
    CharSequence _compile_1 = this.compile(it.getRight());
    _builder.append(_compile_1);
    return _builder;
  }
  
  protected CharSequence _compile(final ArithmeticSigned it) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("-");
    CharSequence _compile = this.compile(it.getExpression());
    _builder.append(_compile);
    return _builder;
  }
  
  protected CharSequence _compile(final Not it) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("!(");
    CharSequence _compile = this.compile(it.getExpression());
    _builder.append(_compile);
    _builder.append(")");
    return _builder;
  }
  
  protected CharSequence _compile(final Equality it) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _compile = this.compile(it.getLeft());
    _builder.append(_compile);
    {
      boolean _equals = it.getOp().equals("==");
      if (_equals) {
        _builder.append(" === ");
      } else {
        _builder.append(" !== ");
      }
    }
    CharSequence _compile_1 = this.compile(it.getRight());
    _builder.append(_compile_1);
    return _builder;
  }
  
  protected CharSequence _compile(final Comparison it) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _compile = this.compile(it.getLeft());
    _builder.append(_compile);
    _builder.append(" ");
    String _op = it.getOp();
    _builder.append(_op);
    _builder.append(" ");
    CharSequence _compile_1 = this.compile(it.getRight());
    _builder.append(_compile_1);
    return _builder;
  }
  
  protected CharSequence _compile(final Display it) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("window.printConsoleOutput(");
    CharSequence _compile = this.compile(it.getExpression());
    _builder.append(_compile);
    _builder.append(")");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  protected CharSequence _compile(final PrimitiveType it) {
    StringConcatenation _builder = new StringConcatenation();
    String _name = it.getName();
    _builder.append(_name);
    return _builder;
  }
  
  protected CharSequence _compile(final IntConstant it) {
    StringConcatenation _builder = new StringConcatenation();
    String _string = Integer.valueOf(it.getValue()).toString();
    _builder.append(_string);
    return _builder;
  }
  
  protected CharSequence _compile(final StringConstant it) {
    String _value = it.getValue();
    String _plus = ("\"" + _value);
    return (_plus + "\"");
  }
  
  protected CharSequence _compile(final BoolConstant it) {
    StringConcatenation _builder = new StringConcatenation();
    String _value = it.getValue();
    _builder.append(_value);
    return _builder;
  }
  
  public CharSequence compileWorkflow(final Workflow it) {
    return _compileWorkflow(it);
  }
  
  public CharSequence compileStep(final Step it) {
    return _compileStep(it);
  }
  
  public CharSequence compileMethod(final Method it) {
    return _compileMethod(it);
  }
  
  public CharSequence compile(final EObject it) {
    if (it instanceof And) {
      return _compile((And)it);
    } else if (it instanceof ArithmeticSigned) {
      return _compile((ArithmeticSigned)it);
    } else if (it instanceof BoolConstant) {
      return _compile((BoolConstant)it);
    } else if (it instanceof Comparison) {
      return _compile((Comparison)it);
    } else if (it instanceof Equality) {
      return _compile((Equality)it);
    } else if (it instanceof Expo) {
      return _compile((Expo)it);
    } else if (it instanceof IntConstant) {
      return _compile((IntConstant)it);
    } else if (it instanceof MethodInvocation) {
      return _compile((MethodInvocation)it);
    } else if (it instanceof Minus) {
      return _compile((Minus)it);
    } else if (it instanceof Mod) {
      return _compile((Mod)it);
    } else if (it instanceof MulOrDiv) {
      return _compile((MulOrDiv)it);
    } else if (it instanceof Not) {
      return _compile((Not)it);
    } else if (it instanceof Or) {
      return _compile((Or)it);
    } else if (it instanceof Plus) {
      return _compile((Plus)it);
    } else if (it instanceof StringConstant) {
      return _compile((StringConstant)it);
    } else if (it instanceof VariableRef) {
      return _compile((VariableRef)it);
    } else if (it instanceof Assignment) {
      return _compile((Assignment)it);
    } else if (it instanceof Display) {
      return _compile((Display)it);
    } else if (it instanceof IfStatement) {
      return _compile((IfStatement)it);
    } else if (it instanceof LoopStatement) {
      return _compile((LoopStatement)it);
    } else if (it instanceof PrimitiveType) {
      return _compile((PrimitiveType)it);
    } else if (it instanceof Return) {
      return _compile((Return)it);
    } else if (it instanceof Variable) {
      return _compile((Variable)it);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(it).toString());
    }
  }
}
